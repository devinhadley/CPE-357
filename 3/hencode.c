/*
 * hencode.c
 * Implements the Huffman coding algorithm to generate Huffman
 * codes for each byte in a given file. The program first reads the input file
 * and populates a frequency table with the number of occurrences of each byte
 * in the file. It then creates a linked list of Huffman nodes for each byte
 * with a non-zero frequency, sorts the list by frequency, and creates a Huffman
 * tree from the list of nodes. The program then recursively traverses the
 * Huffman tree to generate Huffman codes for each byte and stores the codes in
 * an array. Finally, the program prints the generated Huffman codes for each
 * byte.*/

#include "bitwriter.h"
#include "huffman.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BYTES_MAX 256
#define HEX_MAX 16
#define BUF_SIZE 4096

extern char *strdup(const char *);

void populate_frequency_table(unsigned int *frequency_table, int fd) {
  /* Fills the frequency table argument with the frequencies found in the
   * provided file. */
  unsigned char buf[BUF_SIZE];
  int bytes_read;
  int i;

  while ((bytes_read = read(fd, buf, BUF_SIZE)) > 0) {
    for (i = 0; i < bytes_read; i++) {
      frequency_table[(unsigned int)buf[i]]++;
    }
  }

  if (bytes_read == -1) {
    fprintf(stderr, "Failed to read from input file");
    close(fd);
    exit(1);
  }
}

void store_codes(char *codes[], HuffmanNode *node, char *code, int depth) {
  /* Stores the codes generated by the huffman tree into the codes array. */

  /* Guard statement to handle NULL nodes */
  char *copied_code;

  if (node == NULL) {
    return;
  }

  /* Guard statement to handle leaf nodes */
  if (node->left == NULL && node->right == NULL) {
    code[depth] = '\0';

    copied_code = strdup(code);
    codes[node->key] = copied_code;
    return;
  }

  /* traverse left */
  code[depth] = '0';
  store_codes(codes, node->left, code, depth + 1);

  /* traverse right */
  code[depth] = '1';
  store_codes(codes, node->right, code, depth + 1);
}

void free_codes(char *codes[]) {

  int i;

  for (i = 0; i < 256; i++) {
    if (codes[i] != NULL) {
      free(codes[i]);
    }
  }
}

int get_num_codes(char *codes[]) {
  int i;
  int count = 0;
  for (i = 0; i < 256; i++) {
    if (codes[i] != NULL) {
      count += 1;
    }
  }
  return count;
}

void display_codes(char *codes[]) {
  /* for debugging, should be removed from fin */
  int i;
  for (i = 0; i < 256; i++) {
    if (codes[i] != NULL) {
      printf("0x%s%x: %s\n", i < HEX_MAX ? "0" : "", i, codes[i]);
    }
  }
}

int main(int argc, char *argv[]) {
  char *in_file_name;
  unsigned int frequency_table[BYTES_MAX] = {0};
  char *codes[BYTES_MAX] = {NULL};
  char code_buffer[BYTES_MAX];
  int output_fd = 1;
  int input_fd;
  int num_codes;

  HuffmanNode *list = NULL;
  HuffmanNode *tree = NULL;
  BitWriter bw;

  if (argc != 2 && argc != 3) {
    fprintf(stderr, "usage: hencode infile [outfile]\n");
    exit(1);
  }

  /* retrieve input and output file descriptos, defaults to standard in and out
   */
  in_file_name = argv[1];

  input_fd = open(in_file_name, O_RDONLY);
  if (input_fd == -1) {
    fprintf(stderr, "Failed to open file: %s", in_file_name);
    exit(1);
  }

  if (argv[2] != NULL) {
    output_fd = open(argv[2], O_WRONLY | O_TRUNC | O_CREAT, 0644);
    if (output_fd == -1) {
      fprintf(stderr, "Failed to open file: %s", argv[2]);
      exit(1);
    }
  }

  populate_frequency_table(frequency_table, input_fd);
  populate_linked_list(&list, frequency_table);

  if (list == NULL) {
    exit(0);
    close(input_fd);
    close(output_fd);
  }
  populate_huffman_tree(&tree, &list);
  store_codes(codes, tree, code_buffer, 0);

  bitwriter_init(&bw, output_fd);

  num_codes = get_num_codes(codes);
  bitwriter_write_header(&bw, num_codes, frequency_table);

  /* reset the input file pointer */
  if (lseek(input_fd, 0, SEEK_SET) == -1) {
    perror("Failed to reset input file pointer.");
    exit(EXIT_FAILURE);
  }
  bitwriter_translate_file(&bw, input_fd, codes);

  free_codes(codes);
  free_tree(tree);

  return 0;
}
